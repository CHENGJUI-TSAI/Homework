# 41243252
# 41243249

作業一

## 解題說明

本題結合題目要求排序法，計算排序執行時間。

### 解題策略

1.Insertion Sort

將陣列分成「已排序區段」和「待排序區段」。
依序把每個新元素插入到前面已排序的正確位置。

2.Quick Sort

選一個 pivot（此版用區段中點元素）。
把陣列分成「小於 pivot」和「大於 pivot」兩部分，並遞迴排序這兩個子區段。

3.Merge Sort

不斷把陣列二分成左右兩半。
對左右半部各自遞迴排序，然後把兩個已排序序列「合併」成一個。

4.Heap Sort

先用 make_heap 建立最大（或最小）堆。
再用 sort_heap 逐步取出堆頂元素，完成排序。

5.Composite Sort (IntroSort)

對小區段（≤16 元素）直接用插入排序，減少遞迴開銷。
設定深度上限 2·log₂(n)：
當遞迴深度耗盡時，切換到堆排序，避免最壞情況退化。
否則，使用三取中法選 pivot，照快速排序流程繼續遞迴。
## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int sigma(int n) {
    if (n < 0)
        throw "n < 0";
    else if (n <= 1)
        return n;
    return n + sigma(n - 1);
}

int main() {
    int result = sigma(3);
    cout << result << '\n';
}
```

## 效能分析

| 排序演算法     | 最佳時間複雜度     | 平均時間複雜度    | 最差時間複雜度     | 空間複雜度               |
|---------------|--------------------|-------------------|--------------------|--------------------------|
| 插入排序      | O(n)               | O(n²)             | O(n²)              | O(1)            |
| 快速排序      | O(n log n)         | O(n log n)        | O(n²)              | O(log n)       |
| 合併排序      | O(n log n)         | O(n log n)        | O(n log n)         | O(n)        |
| 堆積排序      | O(n log n)         | O(n log n)        | O(n log n)         | O(1)             |
| 複合排序      | O(n) / O(n log n)  | O(n log n)        | O(n log n)         | O(n) / O(log n)          |


## 測試與驗證
測量結果簡要驗證了各演算法的理論複雜度：

1.插入排序耗時隨資料規模呈二次增長（O(n²)）；

2.快速排序、合併排序、堆積排序的平均／最差時間均隨 n log n 緩增；

3.複合排序在所有規模下耗時最少，也符合其優化組合策略的高效性。

### 測試案例
平均時間
| n   | Insertion | Quick  | Merge  | Heap   | Composite |
|-----|-----------|--------|--------|--------|-----------|
| 500 | 0.6068    | 0.0455 | 1.1890 | 0.0758 | 0.1204    |
|1000 | 2.0992    | 0.0814 | 2.3945 | 0.1423 | 0.0796    |
|2000 | 8.1600    | 0.2651 | 5.1443 | 0.3797 | 0.1991    |
|3000 | 18.1957   | 0.3954 | 7.0548 | 0.4775 | 0.3083    |
|5000 | 36.3755   | 0.6180 | 14.1256| 1.2018 | 0.7820    |

最差時間
| n   | Insertion | Quick  | Merge  | Heap   | Composite |
|-----|-----------|--------|--------|--------|-----------|
| 500 | 0.9280    | 0.0510 | 1.4180 | 0.1760 | 0.8980 |
|1000 | 2.8760    | 0.1230 | 3.1040 | 0.1490 | 0.0940 |
|2000 | 11.0800   | 0.3620 | 5.7550 | 0.5970 | 0.2140 |
|3000 | 22.8290   | 0.3850 | 7.6550 | 0.5070 | 0.3730 |
|4000 | 40.8800   | 0.6890 | 11.0380 | 0.6630 | 0.4050 |
|5000 | 59.4090   | 0.6430 | 18.8620 | 1.5280 | 1.0110 |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o sigma sigma.cpp
$ ./sigma
6
```

### 結論

1. 測驗結果顯示，插入排序適合在小規模資料（n ≤ 500），但隨 n 增大，其執行時間快速惡化，完全符合 O(n²) 的二次增長特性。

2.快速排序、合併排序與堆積排序在中、大規模資料（n ≥ 1000）下均展現穩定的 O(n log n) 性能，其中快速排序因較低的常數而通常最快，但最差 
  情況下可能退化至 O(n²)；合併排序最差情況亦為 O(n log n)；堆積排序則在記憶體使用上最省。

3.複合排序透過切換至插入排序處理小區間，並在較大區塊中套用分治策略，實測平均與最差均優於單一演算法，驗證其在混合場景下的優越性。



### 應用建議

小資料量（n < 1000）：可優先考慮複合排序或插入排序，以簡單、低常數因子獲得最好效能。

中大型資料量（1000 ≤ n ≤ 10⁶）：可考慮快速排序與合併排序，若需最差時間保證，合併排序更為穩健；若記憶體受限，則考慮堆積排序。

極大規模（n ≫ 10⁶）或分散式場景：合併排序易於並行化分割，若有多執行緒／多核環境，可進一步採用多路合併或外部排序技術。
2. **易於理解與實現**  
   遞迴的程式碼更接近數學公式的表示方式，特別適合新手學習遞迴的基本概念。  
   以本程式為例：  

   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

3. **遞迴的語意清楚**  
   在程式中，每次遞迴呼叫都代表一個「子問題的解」，而最終遞迴的返回結果會逐層相加，完成整體問題的求解。  
   這種設計簡化了邏輯，不需要額外變數來維護中間狀態。

透過遞迴實作 Sigma 計算，程式邏輯簡單且易於理解，特別適合展示遞迴的核心思想。然而，遞迴會因堆疊深度受到限制，當 $n$ 值過大時，應考慮使用迭代版本來避免 Stack Overflow 問題。
