# 41243252
# 41243249

作業一

## 解題說明

本題結合題目要求排序法，計算排序執行時間。

### 解題策略

1.Insertion Sort

將陣列分成「已排序區段」和「待排序區段」。
依序把每個新元素插入到前面已排序的正確位置。

2.Quick Sort

選一個 pivot（此版用區段中點元素）。
把陣列分成「小於 pivot」和「大於 pivot」兩部分，並遞迴排序這兩個子區段。

3.Merge Sort

不斷把陣列二分成左右兩半。
對左右半部各自遞迴排序，然後把兩個已排序序列「合併」成一個。

4.Heap Sort

先用 make_heap 建立最大（或最小）堆。
再用 sort_heap 逐步取出堆頂元素，完成排序。

5.Composite Sort (IntroSort)

對小區段（≤16 元素）直接用插入排序，減少遞迴開銷。
設定深度上限 2·log₂(n)：
當遞迴深度耗盡時，切換到堆排序，避免最壞情況退化。
否則，使用三取中法選 pivot，照快速排序流程繼續遞迴。
## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int sigma(int n) {
    if (n < 0)
        throw "n < 0";
    else if (n <= 1)
        return n;
    return n + sigma(n - 1);
}

int main() {
    int result = sigma(3);
    cout << result << '\n';
}
```

## 效能分析

1. 時間複雜度：程式的時間複雜度為 $O(\log n)$。
2. 空間複雜度：空間複雜度為 $O(100\times \log n + \pi)$。

## 測試與驗證
測量結果簡要驗證了各演算法的理論複雜度：

1.插入排序耗時隨資料規模呈二次增長（O(n²)）；

2.快速排序、合併排序、堆積排序的平均／最差時間均隨 n log n 緩增；

3.複合排序在所有規模下耗時最少，也符合其優化組合策略的高效性。

### 測試案例
平均時間
| n   | Insertion | Quick  | Merge  | Heap   | Composite |
|-----|-----------|--------|--------|--------|-----------|
| 500 | 0.6068    | 0.0455 | 1.1890 | 0.0758 | 0.1204    |
|1000 | 2.0992    | 0.0814 | 2.3945 | 0.1423 | 0.0796    |
|2000 | 8.1600    | 0.2651 | 5.1443 | 0.3797 | 0.1991    |
|3000 | 18.1957   | 0.3954 | 7.0548 | 0.4775 | 0.3083    |
|5000 | 36.3755   | 0.6180 | 14.1256| 1.2018 | 0.7820    |

最差時間
| n   | Insertion | Quick  | Merge  | Heap   | Composite |
|-----|-----------|--------|--------|--------|-----------|
| 500 | 0.9280    | 0.0510 | 1.4180 | 0.1760 | 0.8980 |
|1000 | 2.8760    | 0.1230 | 3.1040 | 0.1490 | 0.0940 |
|2000 | 11.0800   | 0.3620 | 5.7550 | 0.5970 | 0.2140 |
|3000 | 22.8290   | 0.3850 | 7.6550 | 0.5070 | 0.3730 |
|4000 | 40.8800   | 0.6890 | 11.0380 | 0.6630 | 0.4050 |
|5000 | 59.4090   | 0.6430 | 18.8620 | 1.5280 | 1.0110 |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o sigma sigma.cpp
$ ./sigma
6
```

### 結論

1. 程式能正確計算 $n$ 到 $1$ 的連加總和。  
2. 在 $n < 0$ 的情況下，程式會成功拋出異常，符合設計預期。  
3. 測試案例涵蓋了多種邊界情況（$n = 0$、$n = 1$、$n > 1$、$n < 0$），驗證程式的正確性。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

1. **程式邏輯簡單直觀**  
   遞迴的寫法能夠清楚表達「將問題拆解為更小的子問題」的核心概念。  
   例如，計算 $\Sigma(n)$ 的過程可分解為：  

   $$
   \Sigma(n) = n + \Sigma(n-1)
   $$

   當 $n$ 等於 1 或 0 時，直接返回結果，結束遞迴。

2. **易於理解與實現**  
   遞迴的程式碼更接近數學公式的表示方式，特別適合新手學習遞迴的基本概念。  
   以本程式為例：  

   ```cpp
   int sigma(int n) {
       if (n < 0)
           throw "n < 0";
       else if (n <= 1)
           return n;
       return n + sigma(n - 1);
   }
   ```

3. **遞迴的語意清楚**  
   在程式中，每次遞迴呼叫都代表一個「子問題的解」，而最終遞迴的返回結果會逐層相加，完成整體問題的求解。  
   這種設計簡化了邏輯，不需要額外變數來維護中間狀態。

透過遞迴實作 Sigma 計算，程式邏輯簡單且易於理解，特別適合展示遞迴的核心思想。然而，遞迴會因堆疊深度受到限制，當 $n$ 值過大時，應考慮使用迭代版本來避免 Stack Overflow 問題。
